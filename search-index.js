var searchIndex = {};
searchIndex["allocators"] = {"doc":"This tiny crate defines a simple allocator interface.","items":[[3,"DefaultHeap","allocators","An implementation of `Allocator` that allocates using the default heap allocator",null,null],[8,"Allocator","","A trait for all allocators that collections can be generic about",null,null],[10,"allocate","","Allocate enough memory to store `capacity` of `T`",0,null],[10,"deallocate","","Free previously allocated memory from pointer.",0,null],[11,"allocate","","",1,null],[11,"deallocate","","",1,null]],"paths":[[8,"Allocator"],[3,"DefaultHeap"]]};
searchIndex["chunked"] = {"doc":"This crate offers an abstraction over allocating fixed-size chunks of memory and different low-level collection types making use of these chunks to emulate \"infinite\" dynamically growing storage.","items":[[3,"MemChunker","chunked","Implementation of `Chunker` for temporary heap memory",null,null],[3,"ValueInChunk","","A simple value, stored in a chunk. Typically used to store metadata of collections (such as length) using the same kind of (non-)persistence as the items of the collection",null,null],[3,"SizedChunkedArena","","A simple array-like collection of fixed-size items of unknown type",null,null],[12,"chunker","","Chunker which is used to create and destroy chunks as needed",0,null],[12,"chunks","","List of allocated chunks",0,null],[12,"item_size","","Item size in bytes",0,null],[3,"ChunkedVec","","A vector which stores items of a known type in a `SizedChunkedArena`",null,null],[3,"ChunkedQueue","","A FIFO queue which stores heterogeneously sized items",null,null],[3,"MultiSized","","Based on a collection type for fixed-size items (\"Bin\"), creates a collection for heterogenously-sized items which will be stored in the most appropriately-sized bin.",null,null],[12,"bins","","All fixed-size bins in this multi-sized collection",1,null],[8,"Chunker","","Describes a strategy for creation and destruction of chunks, adhering to configurable settings",null,null],[10,"chunk_size","","Get the set chunk size",2,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[10,"name","","Get the set chunk name root",2,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[10,"with_chunk_size","","Create an identical chunker, but with different chunk size",2,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"box"}}],[10,"with_name","","Create an identical chunker, but with a different name",2,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"box"}}],[10,"child","","Create an identical chunker, with the name of the current chunker extended by a suffix.",2,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"box"}}],[10,"create_chunk","","Create a new chunk with the set chunk size",2,null],[11,"load_chunk","","Load a persisted chunk that was previously created by this chunker, given an index to identify the particular chunk. *Note:* the default implementation just creates a new, empty chunk",2,null],[10,"destroy_chunk","","Destroys a chunk that was created by this chunker as well as any persisted representation of the chunk.",2,null],[8,"SizedChunkedCollection","","Any kind of dynamically-growing collection of fixed-size items that uses chunks",null,null],[10,"new","","Create a new collection based on a chunker and item size",3,{"inputs":[{"name":"box"},{"name":"usize"}],"output":{"name":"self"}}],[11,"clone","","",4,{"inputs":[{"name":"self"}],"output":{"name":"memchunker"}}],[11,"from_settings","","Create a new `MemChunker` with the given settings",4,{"inputs":[{"name":"str"},{"name":"usize"}],"output":{"name":"box"}}],[11,"chunk_size","","",4,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"name","","",4,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"with_chunk_size","","",4,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"box"}}],[11,"with_name","","",4,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"box"}}],[11,"child","","",4,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"box"}}],[11,"create_chunk","","",4,null],[11,"destroy_chunk","","",4,null],[11,"new","","Create a new value with a given default. The default is used if no persisted chunk for this value was found.",5,{"inputs":[{"name":"box"},{"name":"t"}],"output":{"name":"valueinchunk"}}],[11,"deref","","",5,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[11,"deref_mut","","",5,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[11,"drop","","",5,{"inputs":[{"name":"self"}],"output":null}],[11,"len","","Number of elements in the collection",0,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"is_empty","","Is the collection empty?",0,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"push","","Allocate space for a new item, returns a pointer to where the new item can be written to and the index that the new item will have.",0,null],[11,"pop_away","","Remove the last item from the end",0,{"inputs":[{"name":"self"}],"output":null}],[11,"swap_remove","","Remove the item at index, by swapping it with the last item and then popping, returning the removed item, if it existed.",0,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"option"}}],[11,"at","","Get a pointer to the item at `index`",0,null],[11,"at_mut","","Get a mutable pointer to the item at `index`",0,null],[11,"new","","",0,{"inputs":[{"name":"box"},{"name":"usize"}],"output":{"name":"self"}}],[11,"new","","Create a new chunked vector",6,{"inputs":[{"name":"box"}],"output":{"name":"self"}}],[11,"len","","Get the number of elements in the vector",6,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"is_empty","","Is the chunked vector empty?",6,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"at","","Get a reference to the item at `index`",6,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"item"}}],[11,"at_mut","","Get a mutable reference to the item at `index`",6,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"item"}}],[11,"push","","Push an item onto the vector",6,{"inputs":[{"name":"self"},{"name":"item"}],"output":null}],[11,"pop","","Remove and return the last item, if the vector wasn't empty",6,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"new","","Create a new chunked queue based on a chunker",7,{"inputs":[{"name":"box"}],"output":{"name":"self"}}],[11,"len","","Number of items in the queue",7,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"is_empty","","Is the queue empty?",7,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"enqueue","","Enqueue an item of a given size. Returns a pointer that the item can be written to.",7,null],[11,"dequeue","","Dequeue an item. Returns a pointer to the item in the queue, unless the queue is empty.",7,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"drop_old_chunks","","Delete chunks which have already been read",7,{"inputs":[{"name":"self"}],"output":null}],[11,"new","","Create a new `MultiSized` collection using the given chunker as a main chunker and a base size that represents the smallest expected item size (this will be used as the item size of the smallest-sized Bin)",1,{"inputs":[{"name":"box"},{"name":"usize"}],"output":{"name":"self"}}],[11,"size_to_index","","Get the index of the Bin which stores items of size `size`",1,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"usize"}}],[11,"bin_for_size_mut","","Get a reference to the Bin most appropriately sized given item size `size`",1,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"b"}}]],"paths":[[3,"SizedChunkedArena"],[3,"MultiSized"],[8,"Chunker"],[8,"SizedChunkedCollection"],[3,"MemChunker"],[3,"ValueInChunk"],[3,"ChunkedVec"],[3,"ChunkedQueue"]]};
searchIndex["compact"] = {"doc":"This crate makes it possible to store objects containing dynamic fields either compactly in consecutive memory or using traditional heap pointers.","items":[[3,"CVec","compact","A dynamically-sized vector that can be stored in compact sequential storage and automatically spills over into free heap storage using `Allocator`. Tries to closely follow the API of `std::vec::Vec`, but is not complete.",null,null],[3,"CDict","","A simple linear-search key-value dictionary, implemented using two `CompactVec`'s, one for keys, one for values.",null,null],[11,"len","","Get the number of elements in the vector",0,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"is_empty","","Is the vector empty?",0,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"new","","Create a new, empty vector",0,{"inputs":[],"output":{"name":"compactvec"}}],[11,"with_capacity","","Create a new, empty vector with a given capacity",0,{"inputs":[{"name":"usize"}],"output":{"name":"compactvec"}}],[11,"push","","Push an item onto the vector, spills onto the heap if the capacity in compact storage is insufficient",0,{"inputs":[{"name":"self"},{"name":"t"}],"output":null}],[11,"pop","","Pop and return the last element, if the vector wasn't empty",0,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"insert","","Insert a value at `index`, copying the elements after `index` upwards",0,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"t"}],"output":null}],[11,"remove","","Remove the element at `index`, copying the elements after `index` downwards",0,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"t"}}],[11,"retain","","Take a function which returns whether an element should be kept, and mutably removes all elements from the vector which are not kept",0,{"inputs":[{"name":"self"},{"name":"f"}],"output":null}],[11,"truncate","","Truncate the vector to the given length",0,{"inputs":[{"name":"self"},{"name":"usize"}],"output":null}],[11,"clear","","Clear the vector",0,{"inputs":[{"name":"self"}],"output":null}],[11,"from","","Create a `CompactVec` from a normal `Vec`, directly using the backing storage as free heap storage",0,{"inputs":[{"name":"vec"}],"output":{"name":"self"}}],[11,"drop","","Drop elements and deallocate free heap storage, if any is allocated",0,{"inputs":[{"name":"self"}],"output":null}],[11,"deref","","",0,null],[11,"deref_mut","","",0,null],[11,"into_iter","","",0,null],[11,"is_still_compact","","",0,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"dynamic_size_bytes","","",0,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"compact_from","","",0,null],[11,"decompact","","",0,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[11,"is_still_compact","","",0,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"dynamic_size_bytes","","",0,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"compact_from","","",0,null],[11,"clone","","",0,{"inputs":[{"name":"self"}],"output":{"name":"compactvec"}}],[11,"clone","","",0,{"inputs":[{"name":"self"}],"output":{"name":"compactvec"}}],[11,"from_iter","","",0,{"inputs":[{"name":"i"}],"output":{"name":"self"}}],[11,"extend","","",0,{"inputs":[{"name":"self"},{"name":"i"}],"output":null}],[11,"default","","",0,{"inputs":[],"output":{"name":"compactvec"}}],[11,"fmt","","",0,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Create new, empty dictionary",1,{"inputs":[],"output":{"name":"self"}}],[11,"len","","Amount of entries in the dictionary",1,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"is_empty","","Is the dictionary empty?",1,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"get","","Look up the value for key `query`, if it exists",1,{"inputs":[{"name":"self"},{"name":"k"}],"output":{"name":"option"}}],[11,"get_mru","","Lookup up the value for key `query`, if it exists, but also swap the entry to the beginning of the key/value vectors, so a repeated lookup for that item will be faster",1,{"inputs":[{"name":"self"},{"name":"k"}],"output":{"name":"option"}}],[11,"get_mfu","","Lookup up the value for key `query`, if it exists, but also swap the entry one index towards the beginning of the key/value vectors, so frequently repeated lookups for that item will be faster",1,{"inputs":[{"name":"self"},{"name":"k"}],"output":{"name":"option"}}],[11,"contains_key","","Does the dictionary contain a value for `query`?",1,{"inputs":[{"name":"self"},{"name":"k"}],"output":{"name":"bool"}}],[11,"insert","","Insert new value at key `query` and return the previous value at that key, if any existed",1,{"inputs":[{"name":"self"},{"name":"k"},{"name":"v"}],"output":{"name":"option"}}],[11,"remove","","Remove value at key `query` and return it, if it existed",1,{"inputs":[{"name":"self"},{"name":"k"}],"output":{"name":"option"}}],[11,"keys","","Iterator over all keys in the dictionary",1,{"inputs":[{"name":"self"}],"output":{"name":"iter"}}],[11,"values","","Iterator over all values in the dictionary",1,{"inputs":[{"name":"self"}],"output":{"name":"iter"}}],[11,"values_mut","","Iterator over mutable references to all values in the dictionary",1,{"inputs":[{"name":"self"}],"output":{"name":"itermut"}}],[11,"pairs","","Iterator over all key-value pairs in the dictionary",1,null],[11,"push_at","","Push a value onto the `CompactVec` at the key `query`",1,{"inputs":[{"name":"self"},{"name":"k"},{"name":"i"}],"output":null}],[11,"get_iter","","Iterator over the `CompactVec` at the key `query`",1,null],[11,"remove_iter","","Remove the `CompactVec` at the key `query` and iterate over its elements (if it existed)",1,null],[11,"is_still_compact","","",1,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"dynamic_size_bytes","","",1,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"compact_from","","",1,null],[11,"decompact","","",1,{"inputs":[{"name":"self"}],"output":{"name":"compactdict"}}],[11,"clone","","",1,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[11,"default","","",1,{"inputs":[],"output":{"name":"self"}}],[11,"from_iter","","Construct a compact dictionary from an interator over key-value pairs",1,{"inputs":[{"name":"t"}],"output":{"name":"self"}}],[11,"extend","","Extend a compact dictionary from an iterator over key-value pairs",1,{"inputs":[{"name":"self"},{"name":"t"}],"output":null}],[8,"Compact","","A trait for objects with a statically-sized part and a potential dynamically-sized part that can be stored both compactly in consecutive memory or freely on the heap",null,null],[10,"is_still_compact","","Is the object's dynamic part stored compactly?",2,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[10,"dynamic_size_bytes","","Size of the dynamic part in bytes",2,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"total_size_bytes","","Total size of the object (static part + dynamic part)",2,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[10,"compact_from","","Copy the static part of `source` to `self` and compactly store the dynamic part of `source` as the new dynamic part of `self` at `new_dynamic_part`.",2,null],[11,"behind","","Get a pointer to behind the static part of `self` (commonly used place for the dynamic part)",2,null],[11,"compact_behind_from","","Like `compact_from` with `new_dynamic_part` set to `self.behind()`",2,{"inputs":[{"name":"self"},{"name":"self"}],"output":null}],[10,"decompact","","Creates a clone of self with the dynamic part guaranteed to be stored freely.",2,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[11,"total_size_bytes","","Total size of the object (static part + dynamic part)",2,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"behind","","Get a pointer to behind the static part of `self` (commonly used place for the dynamic part)",2,null],[11,"compact_behind_from","","Like `compact_from` with `new_dynamic_part` set to `self.behind()`",2,{"inputs":[{"name":"self"},{"name":"self"}],"output":null}]],"paths":[[3,"CVec"],[3,"CDict"],[8,"Compact"]]};
searchIndex["compact_macros"] = {"doc":"Automatic `#[derive(Compact)]` macro for structs whose fields are all `Compact`","items":[[5,"derive_compact","compact_macros","",null,{"inputs":[{"name":"tokenstream"}],"output":{"name":"tokenstream"}}]],"paths":[]};
searchIndex["kay"] = {"doc":"`Kay` is a high-performance actor system, suitable for simulating millions of entities.","items":[[3,"Packet","kay","Combination of a message and its destination recipient id",null,null],[12,"recipient_id","","ID of the `Actor`/`SubActor` that should receive this message",0,null],[12,"message","","The message itself",0,null],[3,"ID","","An ID that uniquely identifies an `Actor`, or even a `SubActor` within a `Swarm`",null,null],[12,"type_id","","An ID for the type of the identified `Actor`, used to dispatch messages to the message handling functions registered for this type",1,null],[12,"machine","","For future use: ID for the machine in a computing cluster or multiplayer environment that the identified `Actor` lives on",1,null],[12,"version","","For future use: allows safe reuse of an ID after `Actor`/`SubActor` death. The version is incremented to make the new (otherwise same) ID distinguishable from erroneous references to the `Actor`/`SubActor` previously identified",1,null],[12,"sub_actor_id","","Used to identify sub-actors within a top-level `Actor`. The main use-case is `Swarm` identifying and dispatching to its `SubActors` using this field",1,null],[3,"ActorSystem","","An `ActorSystem` contains the states of all registered actors, message inboxes (queues) for each registered actor, and message handlers for each registered (`Actor`,`Message`) pair.",null,null],[4,"Fate","","Return type of message handling functions, signifying if an `Actor`/`SubActor` should live on after receiving a certain message type.",null,null],[13,"Live","","Means: the `Actor`/`SubActor` should live on",2,null],[13,"Die","","Means: the `Actor`/`SubActor` should be stopped, its state can be deallocated",2,null],[0,"swarm","","Tools for dealing with large amounts of identical actors",null,null],[3,"Swarm","kay::swarm","Offers efficient storage and updating of large numbers of identical `SubActor`s and is typically used whenever there is more than one actor with the same type/behaviour.",null,null],[3,"RequestConfirmation","","A wrapper for messages to request a confirmation about message receival.",null,null],[12,"requester","","Who should the `Confirmation` reply be sent to?",3,null],[12,"message","","Actual message that should be handled",3,null],[3,"Confirmation","","The reply to a `RequestConfirmation`",null,null],[12,"n_recipients","","How many sub-actors actually received and handled the message",4,null],[3,"ToRandom","","A wrapper for messages to send a message to random sub-actors.",null,null],[12,"message","","Actual message that should be handled",5,null],[12,"n_recipients","","Number of randomly selected sub-actors that will receive the message",5,null],[3,"Create","","A message for adding a new sub-actor to a `Swarm` given its initial state.",null,null],[12,"0","","",6,null],[3,"CreateWith","","A message for adding a new sub-actor to a `Swarm` given its initial state and an initial message that the sub-actor will handle immediately after creation.",null,null],[12,"0","","",7,null],[12,"1","","",7,null],[8,"StorageAware","","Trait that allows dynamically sized `SubActors` to provide a \"typical size\" hint to optimize their storage in a `Swarm`",null,null],[11,"typical_size","","The default implementation just returns the static size of the implementing type",8,{"inputs":[],"output":{"name":"usize"}}],[8,"SubActor","","Trait that sub-actors of a `Swarm` have to implement in order for the Swarm to set the sub-actor id and the sub-actor to get its own id in a standardized way.",null,null],[10,"id","","Get the full ID (Swarm type id + sub-actor id) of `self`",9,{"inputs":[{"name":"self"}],"output":{"name":"id"}}],[10,"set_id","","Set the full ID (Swarm type id + sub-actor id) of `self` (called internally by `Swarm`)",9,{"inputs":[{"name":"self"},{"name":"id"}],"output":null}],[8,"RecipientAsSwarm","","Helper trait for dispatching messages either to `SubActor`s of a `Swarm` or the `Swarm` itself.",null,null],[11,"receive","","Analogous to `Recipient::receive`",10,{"inputs":[{"name":"swarm"},{"name":"m"}],"output":{"name":"fate"}}],[11,"receive_packet","","Analogous to `Recipient::receive_packet`",10,{"inputs":[{"name":"swarm"},{"name":"packet"}],"output":{"name":"fate"}}],[11,"new","","Create an empty `Swarm`",11,{"inputs":[],"output":{"name":"self"}}],[11,"all","","Get an ID that refers to all sub-actors inside a `Swarm`. If you send a message to this ID, all sub-actors will receive it (Exception: the Swarm handles the message itself, see `RecipientAsSwarm`)",11,{"inputs":[],"output":{"name":"id"}}],[11,"default","","",11,{"inputs":[],"output":{"name":"self"}}],[11,"receive_packet","","",11,{"inputs":[{"name":"self"},{"name":"packet"}],"output":{"name":"fate"}}],[11,"clone","","",3,{"inputs":[{"name":"self"}],"output":{"name":"requestconfirmation"}}],[11,"is_still_compact","","",3,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"dynamic_size_bytes","","",3,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"compact_from","","",3,null],[11,"decompact","","",3,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[11,"clone","","",4,{"inputs":[{"name":"self"}],"output":{"name":"confirmation"}}],[11,"clone","","",5,{"inputs":[{"name":"self"}],"output":{"name":"torandom"}}],[11,"is_still_compact","","",5,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"dynamic_size_bytes","","",5,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"compact_from","","",5,null],[11,"decompact","","",5,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[11,"clone","","",6,{"inputs":[{"name":"self"}],"output":{"name":"create"}}],[11,"is_still_compact","","",6,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"dynamic_size_bytes","","",6,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"compact_from","","",6,null],[11,"decompact","","",6,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[11,"clone","","",7,{"inputs":[{"name":"self"}],"output":{"name":"createwith"}}],[11,"is_still_compact","","",7,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"dynamic_size_bytes","","",7,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"compact_from","","",7,null],[11,"decompact","","",7,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[11,"clone","kay","",0,{"inputs":[{"name":"self"}],"output":{"name":"packet"}}],[11,"is_still_compact","","",0,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"dynamic_size_bytes","","",0,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"compact_from","","",0,null],[11,"decompact","","",0,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[11,"clone","","",1,{"inputs":[{"name":"self"}],"output":{"name":"id"}}],[11,"eq","","",1,{"inputs":[{"name":"self"},{"name":"id"}],"output":{"name":"bool"}}],[11,"ne","","",1,{"inputs":[{"name":"self"},{"name":"id"}],"output":{"name":"bool"}}],[11,"hash","","",1,null],[11,"new","","Create a new ID",1,{"inputs":[{"name":"shorttypeid"},{"name":"u32"},{"name":"u8"}],"output":{"name":"self"}}],[11,"fmt","","",1,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"shl","","",1,{"inputs":[{"name":"self"},{"name":"m"}],"output":null}],[11,"create_the_system","","Create the global singleton instance of `ActorSystem`. Sets `THE_SYSTEM`. Expects to get a panic callback as a parameter that is called when an actor panics during message handling and can thus be used to for example display the panic error message.",12,{"inputs":[{"name":"box"}],"output":{"name":"box"}}],[11,"send","","Send a message to the actor with a given `ID`. This is usually never called directly, instead, `ID << Message` is used to send messages.",12,{"inputs":[{"name":"self"},{"name":"id"},{"name":"m"}],"output":null}],[11,"process_all_messages","","Processes all sent messages, and messages which are in turn sent during the handling of messages, up to a recursion depth of 1000.",12,{"inputs":[{"name":"self"}],"output":null}],[11,"short_id","","Get the short type id for an `Actor`. Ususally never called directly, use `Actor::id()` instead to get the full ID of a registered Actor.",12,{"inputs":[{"name":"self"}],"output":{"name":"shorttypeid"}}],[7,"THE_SYSTEM","","Global pointer to the singleton instance of `ActorSystem`. Set by `ActorSystem::create_the_system`.",null,null],[8,"Message","","Trait that a datastructure must implement in order to be sent and received as a message.",null,null],[8,"Recipient","","Trait with which message handling for `Actor`/`SubActor`s is implemented",null,null],[11,"receive","","Let's an actor mutate its state when it gets a message, send messages to other actors and determine its new `Fate`",13,{"inputs":[{"name":"self"},{"name":"m"}],"output":{"name":"fate"}}],[11,"receive_packet","","Like `receive`, but allows access to `packet.recipient_id` that the packet/message was sent to. This is used by `Swarm` to dispatch the message to the correct `SubActor`.",13,{"inputs":[{"name":"self"},{"name":"packet"}],"output":{"name":"fate"}}],[8,"Actor","","Any Rust data structure can become an actor by:",null,null],[11,"register_with_state","","Register an `Actor` with the system, using the given instance of the actor type as the initial state for the actor.",14,{"inputs":[{"name":"self"}],"output":null}],[11,"register_default","","Like `register_with_state`, using the default value for `Actor`s that implement `Default`",14,{"inputs":[],"output":null}],[11,"id","","Get the `ID` of an `Actor` (only works after the actor has been registered)",14,{"inputs":[],"output":{"name":"id"}}],[11,"handle","","Register a message handler for a message `M` for an `Actor`, which is defined in the implementation of `Recipient<M> for this actor.",14,{"inputs":[],"output":null}],[11,"handle_critically","","Like `handle`, but marks this message type as *critical* for `Actor`, which means that this actor will still receive such messages even after a panic occured in the `ActorSystem`",14,{"inputs":[],"output":null}],[11,"receive","","Let's an actor mutate its state when it gets a message, send messages to other actors and determine its new `Fate`",13,{"inputs":[{"name":"self"},{"name":"m"}],"output":{"name":"fate"}}],[11,"receive_packet","","Like `receive`, but allows access to `packet.recipient_id` that the packet/message was sent to. This is used by `Swarm` to dispatch the message to the correct `SubActor`.",13,{"inputs":[{"name":"self"},{"name":"packet"}],"output":{"name":"fate"}}],[11,"register_with_state","","Register an `Actor` with the system, using the given instance of the actor type as the initial state for the actor.",14,{"inputs":[{"name":"self"}],"output":null}],[11,"register_default","","Like `register_with_state`, using the default value for `Actor`s that implement `Default`",14,{"inputs":[],"output":null}],[11,"id","","Get the `ID` of an `Actor` (only works after the actor has been registered)",14,{"inputs":[],"output":{"name":"id"}}],[11,"handle","","Register a message handler for a message `M` for an `Actor`, which is defined in the implementation of `Recipient<M> for this actor.",14,{"inputs":[],"output":null}],[11,"handle_critically","","Like `handle`, but marks this message type as *critical* for `Actor`, which means that this actor will still receive such messages even after a panic occured in the `ActorSystem`",14,{"inputs":[],"output":null}]],"paths":[[3,"Packet"],[3,"ID"],[4,"Fate"],[3,"RequestConfirmation"],[3,"Confirmation"],[3,"ToRandom"],[3,"Create"],[3,"CreateWith"],[8,"StorageAware"],[8,"SubActor"],[8,"RecipientAsSwarm"],[3,"Swarm"],[3,"ActorSystem"],[8,"Recipient"],[8,"Actor"]]};
searchIndex["kay_macros"] = {"doc":"Automatic `#[derive(SubActor)]` macro for structs which have an `_id: ID` field.","items":[[5,"derive_actor","kay_macros","",null,{"inputs":[{"name":"tokenstream"}],"output":{"name":"tokenstream"}}]],"paths":[]};
initSearch(searchIndex);
